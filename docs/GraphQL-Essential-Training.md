# GraphQL Essential Training

# Reference

[Lynda.com - GraphQL Essential Training](https://www.lynda.com/GraphQL-tutorials/GraphQL-Essential-Training/614315-2.html)



# 1. Setup and Introduction

## IDE and required tools

## GraphQL overview

A couple years ago, Facebook was facing a challenge with their social network. Anytime you went further than four or five levels deep in your network, Facebook couldn't support it. This is when they created GraphQL. 

GraphQL is a query language for any kind of API and is able to fulfill any queries across multiple databases. So, in other words, it's not a server or a database. **It's a query language**. 

The main benefit of using it is that you can ask for exactly what you want, and you get those results and nothing else. 

If you followed my TypeScript and Testing and Debugging course, you're familiar with type checking. Well, guess what? GraphQL allows you to describe what type of data you can expect. 

GraphQL's ecosystem is in constant growth. Not only you can get started with Facebook's own version of GraphQL, but there are multiple options for you to explore. For example, the Apollo client by the folks at Meteor is built on top of GraphQL and provides several extra features. 

So needless to say that GraphQL is a great tool to add to your development arsenal.



## Server setup with ES6 support

For setting up our GraphQL environment, we need a base server set up and we'll use node to get this going. We'll also install babel so we can use declarative ES6 syntax to import and export our dependencies as we work with our application. 

@ `Desktop` create a new folder. 

```bash
mkdir graphql-essential-training
```

> Name the project anything but graphql, because we're using GraphQL in the project, and when the dependencies are installed, NPM will refuse to install GraphQL if our folder is actually named GraphQL. 

Open the folder in VS Code.

Intiate the project

```bash
npm init
```

Accept the defaults for the creation of a new `package.json` file. 

Just a quick note for those that have a git repository, if you have one, please insert it in the `package.json` file right now. If you don't, when we start the server, sometimes it's going to give you a warning that you don't have a git repository.

We need to start installing a few dependencies here. 

```bash
yarn add express nodemon
```

Install the dev dependencies

```bash
yarn add babel-cli babel-preset-env babel-preset-stage-0 --dev
```

Write a script to start the server

 @ `package.json` 

```json
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "nodemon ./index.js --exec babel-node -e js"
  },
```

We use `nodemon` to restart or refresh the server whenever we change a file in the server, and then we're basically stating that `./index.js` is the entry point of the server. Then all the remaining code is basically making sure that we can run ES6 code inside of node. 

Create a new file

```bash
touch .babelrc
```

In this particular file, we only need to create one object, which will have all the settings for babel

```javascript
{
    "presets": [
        "env",
        "stage-0"
    ]
}
```

Basically those two presets will allow us to run ES6 code in our server. It will precompile the code into JavaScript code that the browser or any JavaScript compiler can read. 

Then let's create `index.js`

```bash
touch index.js
```

We'll import express from express, and then create the app and run express. 

```javascript
import express from 'express';

const app = express();

app.get('/', (req, res) => {
    res.send('GraphQL is amazing!');
});

app.listen(8080, () => console.log('Running server on port localhost:8080/graphql'));
```

Basically, what we're doing now is creating the base server. 

So now we have our base server, we'll add GraphQL on top next.

Test the server

```bash
yarn start
```



## Set up Git and Github Repo

Add `.gitignore`

```bash
touch .gitignore
```

@ `.gitignore`  add a generic node project profile See [Gitignore.io](https://www.gitignore.io)

```
### Node ###
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (http://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Typescript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
```

Initiate Git

```bash
git init
```

Add and commit the files.

```bash
git add . && git commit
```

Push to github

**Create the first porject release** 

Create a stage branch

```bash
git checkout -b stage
```

Add the stage branch to github repo

```bash
git push origin stage
```

Create a release branch from stage

```bash
git checkout -b release-1.0.0 stage
```

Add readme.md

```bash
touch readme.md
```

@ `readme.md`

```markdown
# GraphQL Tutorial with MongoDB and MySQLite

This tutorial demonstrates setting up a GraphQL server built with node using Express and resolves queries to either a MongoSB or a MySQLite DB on the backend

## Use

## Releases

1.0.0 - express server with es6 support.

```

Commit the changes

```bash
git add . && git commit
```

Push the release to origin

```bash
git push origin release-1.0.0
```

**Merge the release branch with the master branch**

switch to master branch

```
git checkout master
```

merge release with master

```
git merge --no-ff release-1.0.0
```

Push master to github

```
git push origin master
```

Tell git what the current release is using as a tag

```
git tag -a 1.0.0
```

push that specific tag to master

```
git push origin 1.0.0
```



**Merge the release branch with the stage branch**

Keep that development team up to date!

switch to stage branch

```
git checkout stage
```

merge release with stage

```
git merge --no-ff release-1.0.0
```

Push to github

```
git push origin stage
```

**Delete the release branch**

Delete locally

```
git branch -d release-1.0.0
```

Delete on Github if you didn't do all the work locally.

```
git push origin --delete release-1.0.0
```



## The initial GraphQL setup

Create a new release branch from stage

```bash
git checkout -b release-1.1.0 stage
```

Append the project readme file

```markdown
 ## Releases

1.0.0 - express server with es6 support.
1.1.0 - initial GraphQL setup.
```



Now that we have our base server set up, let's add GraphQL to it. 

We'll install the dependencies in a second, for now create a new file

```bash
touch schema.js
```

Import buildSchema from graphql. Then create an object which is called schema, and we'll use the function buildSchema that we just imported, like so, and then use the  template strings, and basically start our schema. 

The first thing that we want to do is a query, so the **type** is called Query, and that query is expecting a property called hello, which is a String, like so. Then let's export default schema. 

Save that file

@ `schema.js`

```jsx
import { buildSchema } from 'graphql';

const schema = buildSchema(`
    type Query {
        hello: String
    }
`)

export default schema;
```

The next thing we need to do is update our server file to run GraphQL

@ `index.js`

Import graphqlHTTP and import our schema

```jsx
import graphqlHTTP from 'express-graphql';
import schema from './schema';
```

create a new variable, called root, which returns, a basic resolver

```jsx
const root = { hello: () => "Hi, I'm Manny" };
```

Basically resolvers are functions that returns the data that we need when we make a query with GraphQL. We'll cover that more in details later on. 

Then `apt.use( )`, takes a path here, so the path is `/graphql`, and then we are going to use graphqlHTTP which is a function, and we're passing to that particular function here the schema like so. 

(You can also do just do `schema` if you want to use a short form as opposed to do this, you could also use the ES6 short form here, but I'm going to do this, so you understand what's happening here, if you're not familiar with the short form.) 

Then the rootValue will be root, and then we're setting graphiql to work in this particular server. We're simply stating here that we're going to use graphiql.

OK, so save that

@ `index.js`

```jsx
import express from 'express';
import graphqlHTTP from 'express-graphql';
import schema from './schema';

const app = express();

app.get('/', (req, res) => {
    res.send('GraphQL is amazing!');
});

const root = { hello: () => "Hi, I'm Manny" };

app.use('/graphiql', graphqlHTTP({
    schema: schema,
    rootValue: root,
    graphiql: true,
}))

app.listen(8080, () => console.log('Running server on port localhost:8080/graphql'));
```

We need to install the dependencies that are going to make all this work. 

```bash
yarn add express-graphql graphql
```

OK, so everything is installed, so lets start the server. 

```bash
yarn start
```

Go to `localhost:8080/graphiql`

Now we have GraphiQL working. Let's take a look at the Docs, we have a root type which is a query, so we can make a query and the query has the fields `hello: String`

So if we do a query of `hello`, then it should return what we've coded in our resolver. 

When we start typing things into our GraphiQL server here, we have recommendation as to what we can do. 

@ `localhost:8080/graphiql`

```javascript
query {
  hello 
}
```

then I get the resolver data

```javascript
{
  "data": {
    "hello": "Hi, I'm Smerth"
  }
}
```



**Commit changes**

```bash
git add . && git commit
```



**Checkout master and merge with release**

```bash
git checkout master && git merge --no-ff release-1.1.0 && git push origin master
```



**Tag the release and push**

```bash
git tag -a 1.1.0 && git push origin 1.1.0
```



**Merge the release branch with the stage branch**

```
git checkout stage && git merge --no-ff release-1.1.0 && git push origin stage
```



**Delete the release branch**

Delete locally

```
git branch -d release-1.1.0
```





## Basic GraphQL schema

Create a new release branch from stage

```bash
git checkout -b release-1.2.0 stage
```

Append the project readme file

```markdown
 ## Releases

1.0.0 - express server with es6 support.
1.1.0 - initial GraphQL setup.
1.2.0 - basic GraphQL schema.
```



To be able to make GraphQL queries you need to define a schema which defines the query type and a resolver for each api input. So **type definition** provides what type of data we expect and the **resolver** gets the data for us. 

We'll start by defining our `friends` type for the application and then resolve it with fake data for now. 

@ `schema.js`

So the first thing I want to do is keep the type query but change the hello to friend and then we expect to return a Friend, but right now if we do that it's not going to work because we haven't defined what a Friend type is yet. 

So let's go ahead and do that! 

```jsx
import { buildSchema } from 'graphql';

const schema = buildSchema(`
    type Friend {
        id: ID
        firstName: String
        lastName: String
        gender: String
        language: String
        email: String
    }

    type Query {
        friend: Friend
    }
`)

export default schema;
```

So right now all the data types are Strings. We may have different types as we go through the tutorial, for instance: a string, a number, a boolean, etc... And you have many others that we'll explore as we go through the course. 

So that is pretty much it for our schema so make sure you save it. 

Then let's go in the `index.js` and update it. 

Right now we're resolving `hello` so if we were to do the query with `friend` and returning a `Friend` then this wouldn't work. It would actually throw us an error. The type doesn't match the resolver. So we need to change this. 

So we change `hello` to `friend`, and we create an object and in this object we'll resolve each field that we created in our schema. 

So if you take a look at the schema we had: id, first name, last name, gender, language, email…  so we need to have all these here. 

So for an id we use a fictional number. (This is all fake data but eventually we'll have real data as we get our persistence set up.) 

So we don't change anything else so the schema is basically the same. The rootValue stays the same. Everything else stays the same so let's save that. 

@ `index.js`

```jsx
import express from 'express';
import graphqlHTTP from 'express-graphql';
import schema from './schema';

const app = express();

app.get('/', (req, res) => {
    res.send('GraphQL is amazing!');
});

const root = { friend: () => {
    return {
        "id": 28718992,
        "firstName": "Manny",
        "lastName": "Henri",
        "gender": "Male",
        "language": "English",
        "email": "me@me.com"
    }
} };

app.use('/graphql', graphqlHTTP({
    schema: schema,
    rootValue: root,
    graphiql: true,
}));

app.listen(8080, () => console.log('Running server on port localhost:8080/graphql'));
```

And let's open up our terminal to make sure our server is running. 

```bash
yarn start
```

Let's go inside of GraphiQL and test this. 

If you take a look at the documentation explorer it basically gives you what **type** of queries you can do. Here and it tells you that we can do a query called `friend` and it will return a `Friend`. 

```javascript
query {
  friend {
    firstName
    lastName
    gender
    language
    email
    id
  }
}
```

Returns

```javascript
{
  "data": {
    "friend": {
      "firstName": "Manny",
      "lastName": "Henri",
      "gender": "Male",
      "language": "English",
      "email": "me@me.com",
      "id": "28718992"
    }
  }
}
```



So this is how you make queries, simple queries in graphiQL. One of the things that is really cool about graphiQL is that you can get an history of all the queries and mutations that we're going to do down the road, that you've done. 

There's also another function that you can use here which is called prettify which will basically make your query a lot cleaner and still run successfully. 

So as you can see it's pretty straight forward to build your schema and then run queries only on what you need.



**Push release to github**



# 2. Types and Schemas

## Object types and fields

Create a new release branch from stage

```bash
git checkout -b release-1.3.0 stage
```

Append the project readme file

```markdown
 ## Releases

- 1.0.0 - express server with es6 support.
- 1.1.0 - initial GraphQL setup.
- 1.2.0 - basic GraphQL schema.
- 1.3.0 - object types and fields.
```



If you're familiar with type checking with libraries like TypeScript or Flow, exploring types in GraphQL will be familiar to you. Everything in GraphQL is defined by types as we've done already in our schema. 

So basically when you are defining a type, you are defining the shape of how this data will be and what type of data is expected. 

For example, in your current  `type Friend {}`, we are expecting the data to contain an ID, first name, last name, etc... So this is your object type for the `Friend`. *Like any JavaScript object, inside of it we have the fields and then declare what type of data we expect for this field.* 

For example, first name is a field and we expect a string. The field could be a string, an array of another type, etc... We'll go through every option possible as we go through this course. 

So let's say for example, we want to have multiple emails for this particular `emails:` field here. So what we would do is create a new type called `Email` and then make sure that this type is an array of email.  And if you put an exclamation point, that means that this is mandatory. So that means there needs to be something in that particular field in here. So if we don't have any exclamation point, that means that this particular field can be left empty when we first create it. 

So let's create the `type Email` like so. And basically what we're expecting is an email which is a  string. 

@ `schema.js`

```jsx
    type Friend {
        id: ID
        firstName: String
        lastName: String
        gender: String
        language: String
        emails: [Email]!
    }

    type Email {
        email: String
    }
```



And then all you had to do at this point is change the actual resolver...

@ `index.js`

```javascript
const root = { friend: () => {
    return {
        "id": 28718992,
        "firstName": "Manny",
        "lastName": "Henri",
        "gender": "Male",
        "language": "English",
        "emails": [
            { email: "me@me.com" }, 
            { email: "another@me.com"} 
        ],
    }
} };
```

So there you have it. 

Let's start the server and go back into GraphiQL. 

And then this time if you take a look at the documentation again,  if you take a look at query then friend, this is expecting an array of emails.

```javascript
id: ID
firstName: String
lastName: String
gender: String
language: String
emails: [Email]!
```

So let's say for example, we are calling the emails. 

```javascript
query {
  friend {
    emails {
      email
    }
  }
}
```

Then when we return it, we'll get the array of emails like so. 

```javascript
{
  "data": {
    "friend": {
      "emails": [
        {
          "email": "me@me.com"
        },
        {
          "email": "another@me.com"
        }
      ]
    }
  }
}
```

So the first email, the second email. 

**Push release to github**





## Query and mutation types

Create a new release branch from stage

```bash
git checkout -b release-1.4.0 stage
```

Append the project readme file

```markdown
## Releases

- 1.0.0 - express server with es6 support.
- 1.1.0 - initial GraphQL setup.
- 1.2.0 - basic GraphQL schema.
- 1.3.0 - object types and fields.
- 1.4.0 - query and mutation types.
```



Queries and mutations are the basis of running operations in a GraphQL environment, and we'll explore each type. First, you have queries, which we already coded for our `Friend` type. 

The **Query** type is responsible for defining what will return when we make the query. In this case, we are querying a `Friend` type and therefore, when we run the query, it will return a `Friend` or multiple `Friend` based on the query.

Next we have **Mutations**, which is basically GraphQL's way of changing data, updating, or creating new data, so let's add a mutation type to our project. 

But first lets just remove the emails array here and just make it a simple string.

@ `schema.js`

```jsx
import { buildSchema } from 'graphql';

const schema = buildSchema(`
    type Friend {
        id: ID
        firstName: String
        lastName: String
        gender: String
        language: String
        email: String
    }

    type Query {
        friend: Friend
    }
`)

export default schema;
```

and also in `index.js` 

```jsx
const root = { friend: () => {
    return {
        "id": 28718992,
        "firstName": "Manny",
        "lastName": "Henri",
        "gender": "Male",
        "language": "English",
        "email": "me@me.com",
    }
} };
```



Okay, so the next thing we need to create is a type mutation in `schema.js`, so just go below the **type Query** create the **type Mutation**. So, the type Mutation will basically use a resolver, which is called createFriend, and this resolver will take an input, which we'll call FriendInput. So we'll need to create that input in a second in the schema here. And then it will return a Friend. 

```jsx
    type Mutation {
        createFriend(input: FriendInput): Friend
    }
```

So once we use that mutation, we'll use the resolver create a friend, take the input that we'll define in a second, and then return the friend of that new input. 

Let's go ahead and create that input. Let's just go above the type Mutation and create an input. When you create input types, you need to call them input, like so, and not type, and this is how we define inputs for our mutations. 

```jsx
    input FriendInput {
        id: ID
        firstName: String!
        lastName: String
        gender: String
        language: String
        email: String
    }
```

And then if we want to make any of those values mandatory, again, like I mentioned in the past, we use an exclamation point at the end of the type definition here. 

So, if you want to have the ID to be mandatory, then you put an exclamation point there. So, I'm going to make the firstName mandatory because I know we're going to use firstName in every input that we'll generate. 

And the ID, I'm not going to make mandatory because the ID will be created inside of the resolver and not an input that we take, so that's why I'm not making this one mandatory. 

Okay, so that pretty much sets up our schema, so let's save that. 

@ `schema.js`

```jsx
import { buildSchema } from 'graphql';

const schema = buildSchema(`
    type Friend {
        id: ID
        firstName: String
        lastName: String
        gender: String
        language: String
        email: String
    }

    type Query {
        friend: Friend
    }

    input FriendInput {
        id: ID
        firstName: String!
        lastName: String
        gender: String
        language: String
        email: String
    }

    type Mutation {
        createFriend(input: FriendInput): Friend
    }
`)

export default schema;

```



And then let's go on in the `index.js` 

So let's go ahead and create a class. I want to create a class called Friend. So whenever we create new friends, we'll use that class to initialize that new friend object inside of our database. 

And let's go ahead and use a constructor. And we'll use an id that we'll create ourselves. And then input the firstName, lastName, gender, language, and then email, like so. 

@ `index.js`

```javascript
class Friend {
    constructor(id, { firstName, lastName, gender, language, email }) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
        this.gender = gender;
        this.language = language;
        this.email = email; 
    }
}
```

So basically, when we initialize a constructor, what we pass to that constructor is going to create the new friend inside of our database. 

I want to make sure that I have some kind of database internally, so we're going to create an in-memory database which we'll use until we actually get some persistence with Mongo and SQL. Keep in mind that whenever your server starts or restarts, you're losing any changes to your database. Because it's in-memory, once the server restarts, it resets the memory as well, so make sure to keep that in mind when we work with our in-memory database. 

So let's create the object for the in-memory database, a variable called friendDatabase, and initialize it with an empty object.

@ `index.js`

```javascript
const friendDatabase = {};
```

Then let's create the resolver.  Which will look like this

```jsx
    createFriend: ({input}) => {
        let id = require('crypto').randomBytes(10).toString('hex');
        friendDatabase[id] = input;
        return new Friend(id, input);
    }
```



And again, if you want to remember, the name of that resolver is called createFriend, that will be a function that will take an input called input. 

We can create a random id on the fly using `crypto`

So once we have our id, we're ready to assign it a position in our friendDatabase, like so. And then assign it the input that we got. 

And finally, `return new Friend()` so we have it available for GraphQL.

Okay, so we got everything we need. Let's go ahead and save this, like so. 

```jsx
import express from 'express';
import graphqlHTTP from 'express-graphql';
import schema from './schema';

const app = express();

app.get('/', (req, res) => {
    res.send('GraphQL is amazing!');
});

class Friend {
    constructor(id, { firstName, lastName, gender, language, email }) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
        this.gender = gender;
        this.language = language;
        this.email = email; 
    }
}

const friendDatabase = {};

const root = { 
    friend: () => {
        return {
            "id": 28718992,
            "firstName": "Manny",
            "lastName": "Henri",
            "gender": "Male",
            "language": "English",
            "emails": [
                { email: "me@me.com" }, 
                { email: "another@me.com"} 
            ],
        }
    },
    createFriend: ({input}) => {
        let id = require('crypto').randomBytes(10).toString('hex');
        friendDatabase[id] = input;
        return new Friend(id, input);
    }
};

app.use('/graphiql', graphqlHTTP({
    schema: schema,
    rootValue: root,
    graphiql: true,
}));

app.listen(8080, () => console.log('Running server on port localhost:8080/graphiql'));
```

And let's bring up our server and if we refresh our browser as well, we should have a mutation type here. Let's go ahead and click on the documentation. 

```
query: Query
mutation: Mutation
```

So, it takes createFriend and then it takes an input, and then it will return a friend. 

```
createFriend(input: FriendInput): Friend
```

Let's go ahead and create that mutation. And then when you do a mutation, you have the possibility of returning something. You need at least to return one item. And usually the id is the one by default, so if you're not entering anything here, it will return an id, but I'd like to return the firstName as well. 

```javascript
mutation {
  createFriend(input: {
    firstName: "Hank",
    lastName: "Muckerbee",
    gender: "Male",
    language: "German",
    email: "hank@test.com"    
  }) {
    id
    firstName
    lastName
  }
}
```

Returns

```javascript
{
  "data": {
    "createFriend": {
      "id": "b0d2e81544dde79cca9d",
      "firstName": "Hank",
      "lastName": "Muckerbee"
    }
  }
}
```



In this example, we only created one mutation for creating data, so needless to say, you will have multiple mutations for updating or deleting data. 

You could do mutations without doing an input type, but when you have a similar input for all your mutations, you can create it and therefore make your schema simpler. 

So in conclusion, your input type defines what input your mutations will take. 

So in GraphQL, you need a query type, but you could go without a mutation type.





## What is the resolver and its role?

Create a new release branch from stage

```bash
git checkout -b release-1.5.0 stage
```

Append the project readme file

```markdown
## Releases

- 1.0.0 - express server with es6 support.
- 1.1.0 - initial GraphQL setup.
- 1.2.0 - basic GraphQL schema.
- 1.3.0 - object types and fields.
- 1.4.0 - query and mutation types.
- 1.5.0 - the resolver and its role.
```



Basically, resolvers are the functions that respond to queries and mutations. They are the function that gives us the result of the query. And because the standard approach is to leave the schema only for type definition, we create those functions separate from the schema. 

So you can get either have them in a separate file and then import them into your main server file, or have them into your main entry server file (in this case our `index.js`.) 

Now let's extract the resolvers into their own file and go through the ones we have so far. 

Create a new file

```bash
touch resolvers.js
```



Cut the resolvers out of `index.js` and paste into `resolvers.js`. 

So, in `index.js` your class should be the same, the database should be the same, and then instead of root I will call this resolvers. And then instead of manually returning our friend here let's actually create a function or resolver that will allow us to get a friend once we have created something in our database. 

So let's call this one getFriend, and this will be a function, which will take an ID. And then this function will basically return a new Friend with the ID from the friendDatabase and the position as the ID like so. 

So the last thing you want is to make sure we actually export our resolvers like so. Okay, so we'll save that. 

@ `resolvers.js`

```jsx
class Friend {
    constructor(id, { firstName, lastName, gender, language, email }) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
        this.gender = gender;
        this.language = language;
        this.email = email; 
    }
}

const friendDatabase = {};

const resolvers = { 
    getFriend: ({ id }) => {
        return new Friend(id, friendDatabase[id]);
    },
    createFriend: ({ input }) => {
        let id = require('crypto').randomBytes(10).toString('hex');
        friendDatabase[id] = input;
        return new Friend(id, input);
    }
};

export default resolvers;
```



Then in our index let's make sure that we change our code here to accept our resolvers that are external. So let's make sure that first we import resolvers from resolvers, and then let's make sure that we actually are passing the resolvers to a constant called root like so. 

@ `index.js`

```jsx
import express from 'express';
import graphqlHTTP from 'express-graphql';
import schema from './schema';
import resolvers from './resolvers';

const app = express();

app.get('/', (req, res) => {
    res.send('GraphQL is amazing!');
});

const root = resolvers;

app.use('/graphiql', graphqlHTTP({
    schema: schema,
    rootValue: root,
    graphiql: true,
}));

app.listen(8080, () => console.log('Running server on port localhost:8080/graphiql'));
```



So now everything should be working nicely here, and then the last thing that we need to do is actually define the getFriend in our queries. Let's go ahead and define this here. So in our queries here as opposed to do the friend and return Friend, let's do the getFriend and then we need to pass an ID like so, and then it will return a Friend like so. 

@ `schema.js`

```jsx
    type Query {
        getFriend(id: ID): Friend
    }
```

Okay, so we don't need anything else. We can save that. 

Let's make sure that there's no errors on our server. So let's bring the terminal. Everything is running nicely here.  Because our server has been restarted, we need to create a new friend, otherwise we don't have anything in our database right now, and this is where the history is going to be very useful. 

In GraphiQL the history button gives you access to all the queries you have previously run.  So we can re-run

```javascript
mutation {
  createFriend(input: {
    firstName: "Hank",
    lastName: "Muckerbee",
    gender: "Male",
    language: "German",
    email: "hank@test.com"    
  }) {
    id
    firstName
  }
}
```



So I get an ID for this new friend, so let's go ahead and copy that particular ID here. 

So copy that, and then run the getFriend query

```javascript
query {
 getFriend(id: "202f6b8741aea09076ae"){
  firstName
  lastName
  language
  gender
  email
  }
}
```

Which returns the data

```javascript
{
  "data": {
    "getFriend": {
      "firstName": "Hank",
      "lastName": "Muckerbee",
      "language": "German",
      "gender": "Male",
      "email": "hank@test.com"
    }
  }
}
```

So now that we've got a solid base for our GraphQL server, let's continue exploring other types GraphQL uses. 





## Scalar types

Create a new release branch from stage

```bash
git checkout -b release-1.6.0 stage
```

Append the project readme file

```markdown
## Releases

- 1.0.0 - express server with es6 support.
- 1.1.0 - initial GraphQL setup.
- 1.2.0 - basic GraphQL schema.
- 1.3.0 - object types and fields.
- 1.4.0 - query and mutation types.
- 1.5.0 - the resolver and its role.
- 1.6.0 - scalar types.
```



Scalar types are basic types that come with GraphQL and can be used without having to create a  type beforehand. With GraphQL, we have access to these basic scalar types. We have `int`, for integers, your regular number. We have `float`, which is a float number, which basically includes a decimal point. So, for example, 4.56. We have `string`, for any list of characters, like we've used so far. We have an `ID`, which is a unique identifier for each entry in GraphQL, and we have `boolean`, which has a value of true or false. 

For each field we enter into our type, like our friend type, we need to define what scalar type it takes. 

Let's add a new field with a different scalar type to our schema. Let's go ahead and add to Friend. Whenever we add new things or new fields inside of a specific type we need to make sure that we have the same fields added to anything that influences it. 

For example, if we add age here, and for age we take an integer, then we want to make sure that we also have it in the FriendInput, like so. 

@ `schema.js`

```jsx
import { buildSchema } from 'graphql';

const schema = buildSchema(`
    type Friend {
        id: ID
        firstName: String
        lastName: String
        gender: String
        age: Int
        language: String
        email: String
    }

    type Query {
        getFriend(id: ID): Friend
    }

    input FriendInput {
        id: ID
        firstName: String!
        lastName: String
        gender: String
        age: Int
        language: String
        email: String
    }

    type Mutation {
        createFriend(input: FriendInput): Friend
    }
`)

export default schema;
```



Again, the other thing that we absolutely need to make sure when we add new fields into our types, is to go into the resolvers and make sure that we also update the resolvers. As you remember, we have a class of Friend with a constructor, that initializes these types here. So, we want to make sure that we add also the age. Let's go ahead and do that here.

@ `resolvers.js`

```jsx
class Friend {
    constructor(id, { firstName, lastName, gender, age, language, email }) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
        this.gender = gender;
        this.age = age;
        this.language = language;
        this.email = email; 
    }
}

const friendDatabase = {};

const resolvers = { 
    getFriend: ({ id }) => {
        return new Friend(id, friendDatabase[id]);
    },
    createFriend: ({ input }) => {
        let id = require('crypto').randomBytes(10).toString('hex');
        friendDatabase[id] = input;
        return new Friend(id, input);
    }
};

export default resolvers;

```

Let's go ahead and use some of the mutations we've used in the past, and add age.  Age takes an integer - not a string (try it out)

```javascript
mutation {
  createFriend(input: {
    firstName: "Robert",
    lastName: "Smythe",
    gender: "Male",
    language: "English",
    email: "robert@test.com" 
    age: "thirty"
  }) {
    id
    firstName
    lastName
  }
}
```

Returns the error

```javascript
{
  "errors": [
    {
      "message": "Expected type Int, found \"thirty\".",
      "locations": [
        {
          "line": 8,
          "column": 10
        }
      ]
    }
  ]
}
```

But,

```javascript
mutation {
  createFriend(input: {
    firstName: "Robert",
    lastName: "Smythe",
    gender: "Male",
    language: "English",
    email: "robert@test.com" 
    age: 30
  }) {
    id
    firstName
    lastName
  }
}
```

Creates a Friend in the database and returns the data. 

```javascript
{
  "data": {
    "createFriend": {
      "id": "82259100796c9cffa777",
      "firstName": "Robert",
      "lastName": "Smythe"
    }
  }
}
```



So we can query by id

```javascript
query {
 getFriend(id: "82259100796c9cffa777"){
  firstName
  lastName
  age
  }
}
```

returns

```javascript
{
  "data": {
    "getFriend": {
      "firstName": "Robert",
      "lastName": "Smythe",
      "age": 30
    }
  }
}
```

Okay, so we have age here, and let's return it as well here. There you go. We added a new integer inside of our type. Basically when you create your types you can essentially use any of these scalars for your fields. 

Let's move on. 



## Enumeration types

Create a new release branch from stage

```bash
git checkout -b release-1.7.0 stage
```

Append the project readme file

```markdown
## Releases

- 1.0.0 - express server with es6 support.
- 1.1.0 - initial GraphQL setup.
- 1.2.0 - basic GraphQL schema.
- 1.3.0 - object types and fields.
- 1.4.0 - query and mutation types.
- 1.5.0 - the resolver and its role.
- 1.6.0 - scalar types.
- 1.7.0 - ennumeration types.
```



Enumeration type, or commonly called enums, is a special scalar type that allows you to define a specific set of data the field takes, and restrict the input to what you list in the enum type. 

@ `schema.js`  just below the type on line 12, hit return and we'll set a new enum type. 

We'll set an enum type for Gender. So we want to restrict the choices that gender can take. So we will list the options: MALE, FEMALE, and then OTHER. And by the way, **all the fields inside of an enum should be uppercase**. 

And then make sure that you have that change in here, in `type Friend` in the gender field, so now it's taking a gender type, and also in the input, because if you don't have it in the input, you'll be able to enter a string in the input and then when it returns it, it's not going to be able to return the right values. So let's make sure that we have it here as well, like so. 

```jsx
import { buildSchema } from 'graphql';

const schema = buildSchema(`
    type Friend {
        id: ID
        firstName: String
        lastName: String
        gender: Gender
        age: Int
        language: String
        email: String
    }

    enum Gender {
        MALE
        FEMALE
        OTHER
    }

    type Query {
        getFriend(id: ID): Friend
    }

    input FriendInput {
        id: ID
        firstName: String!
        lastName: String
        gender: Gender
        age: Int
        language: String
        email: String
    }

    type Mutation {
        createFriend(input: FriendInput): Friend
    }
`)

export default schema;

```



And then last, on every change in the schema, always check your resolvers. We don't need to change anything for this one, because gender is already there. 

All right, so let's go and test this in the browser. And let's make sure we refresh our server, like so. And if you want to make sure that everything is fine here, let's go and check the queries.

Under the `docs > mutation > createFriend > FriendInput > Gender`

We can see the allowed options for input to this field

so we can create a friend

```javascript
mutation {
  createFriend(input: {
    firstName: "Robert",
    lastName: "Smythe",
    gender: MALE,
    language: "English",
    email: "robert@test.com" 
    age: 30
  }) {
    id
    firstName
    lastName
    gender
  }
}
```

But it will not accept a value other than: MALE, FEMALE or OTHER

So whenever you need to restrict a type of data the field takes, enums are a great way to do it. 



## List of types inside another

Create a new release branch from stage

```bash
git checkout -b release-1.8.0 stage
```

Append the project readme file

```markdown
## Releases

- 1.0.0 - express server with es6 support.
- 1.1.0 - initial GraphQL setup.
- 1.2.0 - basic GraphQL schema.
- 1.3.0 - object types and fields.
- 1.4.0 - query and mutation types.
- 1.5.0 - the resolver and its role.
- 1.6.0 - scalar types.
- 1.7.0 - ennumeration types.
- 1.8.0 - list of types inside another.
```



In many cases you will need to have multiple values inside of a field, for example, a list of episodes a character is featured in for a television show. 

This is where you can create a type and use the array characters `[]` to signify a list of items inside the field. In our case, we would like to implement a way to list contacts for a friend. Let's get to it. 

So again, open the schema, and inside of our type Friend here, let's create a new field called contacts, like so. 

And then this contacts takes a list of contacts, so you are making an array of a type Contact. So we need to create that type. 

So let's go ahead and create the type Contact, which will basically have a first name, which is a String, and then a last name, which is also a String. And let's make sure we also create an input, so we can enter these contacts. So we need to create a contact input. So just below the input here, let's create a new one, ContactInput.

And in the FriendInput as well, you need to enter that it takes contacts, and we are taking from the ContactInput, like so. 

So there's no other changes on the schema. Save that.

@ `schema.js`

```jsx
import { buildSchema } from 'graphql';

const schema = buildSchema(`
    type Friend {
        id: ID
        firstName: String
        lastName: String
        gender: Gender
        age: Int
        language: String
        email: String
        contacts: [Contact]
    }

    type Contact {
        firstName: String
        lastName: String
    }

    enum Gender {
        MALE
        FEMALE
        OTHER
    }

    type Query {
        getFriend(id: ID): Friend
    }

    input FriendInput {
        id: ID
        firstName: String!
        lastName: String
        gender: Gender
        age: Int
        language: String
        email: String
        contacts: [ContactInput]
    }

    input ContactInput {
        firstName: String
        lastName: String 
    }

    type Mutation {
        createFriend(input: FriendInput): Friend
    }
`)

export default schema;

```



and then in the `resolvers.js`, we need to add the new type in the constructor. 

So after email here, create contacts, and then add it at the end here. So this.contacts equals contacts, like so, and save this. 

@ `resolvers.js`

```jsx
class Friend {
    constructor(id, { firstName, lastName, gender, age, language, email, contacts }) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
        this.gender = gender;
        this.age = age;
        this.language = language;
        this.email = email;
        this.contacts = contacts;
    }
}

const friendDatabase = {};

const resolvers = { 
    getFriend: ({ id }) => {
        return new Friend(id, friendDatabase[id]);
    },
    createFriend: ({ input }) => {
        let id = require('crypto').randomBytes(10).toString('hex');
        friendDatabase[id] = input;
        return new Friend(id, input);
    }
};

export default resolvers;

```



And then we can play with that new type that we created. So let's go ahead and refresh the server one more time. Let's take a look at the documentations, so the mutation will take FriendInput, and in the FriendInput, we have now the new field for contact and then the contact input takes firstName: String, lastName: String. 

Create a friend.  What does contacts take? It takes an array of multiple objects.

```javascript
mutation {
  createFriend(input: {
    firstName: "Robert",
    lastName: "Smythe",
    gender: MALE,
    language: "English",
    email: "robert@test.com" 
    age: 30
    contacts: [
      { firstName: "Chuck", lastName: "Gerber"},
      { firstName: "Albert", lastName: "Schmucker"},
    ]
  }) {
    id
    firstName
    lastName
    gender
    contacts {
      firstName
      lastName
    }
  }
}
```

Returns

```javascript
{
  "data": {
    "createFriend": {
      "id": "768aac2b5b6db7d32468",
      "firstName": "Robert",
      "lastName": "Smythe",
      "gender": "MALE",
      "contacts": [
        {
          "firstName": "Chuck",
          "lastName": "Gerber"
        },
        {
          "firstName": "Albert",
          "lastName": "Schmucker"
        }
      ]
    }
  }
}
```



So I have an array of contacts inside of my new friend. So let's go ahead and also do the query, so copy the ID, and let's go and get the getFriend, and paste that. 

```javascript
query {
 getFriend(id: "768aac2b5b6db7d32468"){
  contacts {
    firstName
      }
  }
}
```

returns

```javascript
{
  "data": {
    "getFriend": {
      "contacts": [
        {
          "firstName": "Chuck"
        },
        {
          "firstName": "Albert"
        }
      ]
    }
  }
}
```



This is just to show you that you can get only the data that you need from GraphQL, and not all the other stuff that you don't.  So you can be as as specific and/or vague as you want with your queries, and get exactly what you need. 

So if you have multiple databases that are connected to GraphQL, and you only want to have specific things from one database and then specific things from the other database, you can literally pick and choose the type of data that you want. 

So as you can see, this is very useful to create sublists of items for your type. So let's move on.

 

## Using GraphQL tools

Create a new release branch from stage

```bash
git checkout -b release-1.9.0 stage
```

Append the project readme file

```markdown
## Releases

...

- 1.9.0 - using graphql tools.
```



As a side note, you will in the community see two approaches to writing schemas, one that is exactly the same as we've been doing here in this schema, and another one that has a lot more code to it and is also more JavaScript friendly. 

So let's go and take a look at both. If you go to [graphql.org/graphql-js/constructing-types](graphql.org/graphql-js/cnostructing-types) and then scroll down to this first area. This is how we've actually build our schema so far, but there's also a second approach where you'll see something like this where you are creating a new `GraphQLObjectType`, and then name User, and then define the fields, and so on and so forth. 

Both approaches are good, but because the first syntax here is a lot simpler this is exactly what we'll use from this point forward.  However it requires to use some tools,

Let's go ahead and install some tools that we'll need for our future videos. 

@ VS Code, open up your terminal. 

```bash
yarn add graphql-tools
```

Now we'll refactor a little bit of our code to accept the new tool and leverage some of the features that comes with it. 

First let's update our schema. 

So what I want to do as opposed to create a const schema, let's call it typeDefs like so, and let's remove this, and make sure you remove the last parenthesis here like so, and do a semicolon. 

And what we'll do as opposed to import buildSchema, we'll import the resolvers from resolvers, and we'll also import makeExecutableSchema from graphql-tools. 

As opposed to export default schema, let's do a const schema equals makeExecutableSchema and use the typeDefs and the resolvers, and then export scheme, but with curly braces like so. 



@ `schema.js`

```jsx
import { resolvers } from './resolvers';
import { makeExecutableSchema } from 'graphql-tools';

const typeDefs = `
    type Friend {
        id: ID
        firstName: String
        lastName: String
        gender: Gender
        age: Int
        language: String
        email: String
        contacts: [Contact]
    }

    type Contact {
        firstName: String
        lastName: String
    }

    enum Gender {
        MALE
        FEMALE
        OTHER
    }

    type Query {
        getFriend(id: ID): Friend
    }

    input FriendInput {
        id: ID
        firstName: String!
        lastName: String
        gender: Gender
        age: Int
        language: String
        email: String
        contacts: [ContactInput]
    }

    input ContactInput {
        firstName: String
        lastName: String 
    }

    type Mutation {
        createFriend(input: FriendInput): Friend
    }
`;

const schema = makeExecutableSchema({ typeDefs, resolvers});

export { schema };

```



Then @ `resolvers.js` 

We will call a resolver map. This is something that has been introduced with the `graphql-tools`, and it helps us to map our resolvers better. 

So instead of doing just a const, let's export the resolvers, and then create inside of our resolvers a Query, and then the Query object will have query resolver like so. 

Nothing changing in terms of the resolvers itself, but it needs to mapped out better. 

So then we'll create Mutation, which is an object, and paste in the Mutation object. 

@ `resolvers.js` 

```jsx
class Friend {
    constructor(id, { firstName, lastName, gender, age, language, email, contacts }) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
        this.gender = gender;
        this.age = age;
        this.language = language;
        this.email = email;
        this.contacts = contacts;
    }
}

const friendDatabase = {};

// resolver map
export const resolvers = {
    Query: {
        getFriend: ({ id }) => {
            return new Friend(id, friendDatabase[id]);
        },
    },
    Mutation: {
        createFriend: ({ input }) => {
            let id = require('crypto').randomBytes(10).toString('hex');
            friendDatabase[id] = input;
            return new Friend(id, input);
        },
    },
};

```

Now @ `index.js`

The last thing you need to do is to properly import your schema here, and you're importing it with curly braces like so, and we don't need the resolvers anymore like so because we're going to do something different very, very soon. So let's remove that. 

We don't need the value here, so let's remove that, and by the way everything that we're doing now is to prepare our GraphQL server to accept persistence and work with Mongo and SQL. 

So this is why we're making some little changes here. So let's go ahead and remove the rootValue here, we don't need it anymore.

The schema you can leave it as it is or you can do it the ES6 way like so if you want. Both ways work. 

Okay, and then save this.

```jsx
import express from 'express';
import graphqlHTTP from 'express-graphql';
import { schema } from './schema';

const app = express();

app.get('/', (req, res) => {
    res.send('GraphQL is amazing!');
});

app.use('/graphiql', graphqlHTTP({
    schema: schema,
    graphiql: true,
}));

app.listen(8080, () => console.log('Running server on port localhost:8080/graphiql'));
```

Okay, so now that we have our project updated with the GraphQL tools, let's move on





# 3. Setting Up Persistence

## Installing Mongo for GraphQL

Right now our data is only saved in memory and when we stop, the server would lose any data persistence. So with our GraphQL server up and running and now with some knowledge about how it works, let's add data persistence with MongoDB. 

First go to [mongodb.com](mongodb.com) and then scroll all the way down and click on installation here and then install MongoDB Community Edition and then select the operating system you're running on. 

We'll use Homebrew to install the Community Edition and then we'll do a couple commands that are required in order to make MongoDB run. 

So let's go ahead and first install Homebrew. 

If you already have Homebrew installed, I would suggest you do a `brew update`. 

Install Mongo.db

```bash
brew install mongo
```

 Once you have this installed, there's another step that you need to do and unfortunately we can't do it in this terminal because we are in this particular directory, we need to do that in the root directory, so and let's open a regular terminal on Mac. 

@ `root directory`

```bash
mkdir -p /data/db
```

What we're doing here is creating the directory for the database. 

Once this is done, you need to set the permissions. So the way you do this is by doing

```bash
sudo chmod 777 /data/db
```

Then we can start Mongo and you do that by doing

```bash
mongod
```

And if everything is running like this, that means that it is installed and running properly. 



> If you have a warning when starting Mongo see this [Fix Warning](https://stackoverflow.com/questions/25251151/mongo-server-startup-warnings#25251369) and [this](https://docs.mongodb.com/manual/reference/ulimit/)
>
> ```bash
> ulimit -n 1024 && mongod
> ```
>
> then restart `mongod`
>
> You need to redo this after every computer reboot.



> To shut down mongo 
>
> on [Mac OS X](https://docs.mongodb.org/manual/tutorial/install-mongodb-on-os-x/)
>
> - Find PID of mongod process using `$ top`
> - Kill the process by `$ kill <PID>` ([the Mongo docs have more info on this](https://docs.mongodb.org/manual/tutorial/manage-mongodb-processes/#use-kill))



Now back @ `project root`  let's install Mongoose. 

So a quick introduction, so Mongoose basically is a library to help us with modeling our database and bring several built-in tools to help us with validation, business logic hooks, etc... 

So if you'd like to get more details around Mongoose, feel free to take a look at the documentation in depth. We'll cover some of the basics as we build our APIs so let's go ahead and install Mongoose. 

```bash
yarn add mongoose
```

Okay, so now got Mongoose and we got MongoDB ready to go so let's move on.



## Final setup of Mongo with GraphQL

Now that we have the necessary items to connect to Mongo database, let's finalize our server to properly connect to it. 

@ `project root`

```bash
mkdir data
```

I'm going to do is move the `resolvers.js` and   `schema.js`  inside of data.

And please, keep in mind that we need to properly import here so we need to add also data here. 

@ `index.js`

```jsx
import { schema } from './data/schema';
```



And then, let's create a new file inside of data. 

@ `/data/`

```bash
touch ./data/dbConnectors.js
```

And, in this particular file is where we're going to connect to our databases. 

So first we need to connect to Mongo. So we'll do this with mongoose

```jsx
import mongoose from 'mongoose';
```

Let's coment the next section `// Mongo connection`, so we can refer to it later on if there's any issues. 

And, we'll use `mongoose.Promise = global.Promise`, so basically what we're doing here is  when we connect to Mongo we are using a promise to do so. We're not waiting for the connection to go on with our lives. 

`mongoose.connect()` takes a database path and a configuration object. Please set this option, `useMongoClient` to true, because if you're not using this particular option, it's not going to work. And I did mention this in one of my previous videos, why that is. 

```jsx
// Mongo connection
mongoose.Promise = global.Promise;
mongoose.connect('mongodb://localhost/friends', {
    useMongoClient: true
});
```

And then we're going to create the schema for Mongo. So we're going to call this one `const friendSchema = new mongoose.Schema({})`, and this is a function, which creates an object, and now we need to add all the things that we used in our schema. 

```jsx
const friendSchema = new mongoose.Schema({
    firstName: {
        type: String
    },
    lastName: {
        type: String
    },
    gender: {
        type: String
    },
    age: {
        type: Number
    },
    language: {
        type: String
    },
    email: {
        type: String
    },
    contacts: {
        type: Array
    }
});
```

Alright, so basically what we've done here is we connect to Mongo, then we create a schema here, with all the stuff that we had in our schema here as well. 

So then what I want to do is create a new model here. Passing the schema and this is the name of the model. 

```jsx
const Friends = mongoose.model('friends', friendSchema);

export { Friends };
```

And save this file. 

@ `dbConnectors.js`

```jsx
import mongoose from 'mongoose';

// Mongo connection
mongoose.Promise = global.Promise;
mongoose.connect('mongodb://localhost/friends', {
    useMongoClient: true
});

const friendSchema = new mongoose.Schema({
    firstName: {
        type: String
    },
    lastName: {
        type: String
    },
    gender: {
        type: String
    },
    age: {
        type: Number
    },
    language: {
        type: String
    },
    email: {
        type: String
    },
    contacts: {
        type: Array
    }
});

const Friends = mongoose.model('friends', friendSchema);

export { Friends };
```

The last thing we need to do is change our resolvers and we need to change quite a bit. 

Because we don't need to create our in memory database anymore, we can all get rid of this. So basically everything that we had from the database, and the constructor, and the class. We don't need any of that anymore. 

Now, we need to import mongoose again from mongoose, like so.  And we're going to import Friends, like so, from dbConnectors. 

So, what is going to change basically is how we mutate. So, we'll work on the query a little bit later on, but for now, what we'll do is change our mutation because when we create new things inside of our database, this is going to change. 

This was the old way, when we were creating it in memory. And now, we're going to create it inside of our database Mongo. 

Alright, so the first thing I want to change here is in the arguments, I want you to add root and then everything else is the same here. 

And then inside of this particular, we are going to change all this here, so let's remove all that. And then we'll create a newFriend object, which is a new Friends. So now we're leveraging, this is no longer a class, we're actually leveraging the friends that we've imported from the connectors. And, this will allow us to create a newFriend inside of our database. 

```jsx
    Mutation: {
        createFriend: (root, { input }) => {
            const newFriend = new Friends({
                firstName: input.firstName,
                lastName: input.lastName,
                gender: input.gender,
                age: input.age,
                language: input.language,
                email: input.email,
                contacts: input.contacts
            });
```



So now that we have our object, our newFriend object created with the inputs that we got in our function, in our resolver. What we need to do after that is create inside of the database the new items. 

So, newFriend, and we'll assign it an ID. Equals newFriend underscore id, so this is something that is assigned directly from the database.

```jsx
newFriend.id = newFriend._id
```

And then, what we'll do is return a new Promise because we'll send basically our object that's just been created to the Mongo database and then we need to wait for a response before we can actually resolve it inside of our GraphQL server.

So, let's resolve, let's pass the argument resolve. And pass an object, which will come from the promises. So then, we are saving it to the mongoDB. And we're passing an error as an argument so if there's any errors while we save it, we want to know. If there's an error, then reject the error, else resolve our Promise with our newFriend. 

```jsx
            return new Promise((resolve, object) => {
                newFriend.save((err) => {
                    if (err) reject(err)
                    else resolve(newFriend)
                })
            })
```



So basically what we'll get at that point is the result, which will be returned inside of our GraphQL server. Okay. So, that's pretty much it. Alright, just before we leave, make sure you save. 

@ `resolvers.js`

```jsx
import mongoose from 'mongoose';
import { Friends } from './dbConnectors';

// resolver map
export const resolvers = {
    Query: {
        getFriend: ({ id }) => {
            return new Friend(id, friendDatabase[id]);
        },
    },
    Mutation: {
        createFriend: (root, { input }) => {
            const newFriend = new Friends({
                firstName: input.firstName,
                lastName: input.lastName,
                gender: input.gender,
                age: input.age,
                language: input.language,
                email: input.email,
                contacts: input.contacts
            });

            newFriend.id = newFriend._id;

            return new Promise((resolve, object) => {
                newFriend.save((err) => {
                    if (err) reject(err)
                    else resolve(newFriend)
                })
            }) 
        },
    },
};

```



Okay, so now we have mongo setup, now let's move on. 







## Data persistence with SQL

Create a new release branch from stage

```bash
git checkout -b release-1.10.0 stage
```

Append the project readme file

```markdown
## Releases

...

- 1.10.0 - data persistance with SQLite.
```



Now that we have Mongo set up, let's add a second database and install SQLite. So, the first thing we want to do is install a few things inside of your `package.json`. 

```bash
yarn add casual lodash sequelize sqlite3
```

Okay. And now what we want to do is get inside of our dbConnectors 'cause now we're going to create a connection to SQLite. 

And we're going to do this by first importing, import Sequelize, like so, from 'sequelize'. Then we're going to import lodash, and when you import lodash, this is the common practice where you do an underscore like that. And we're going to import casual from 'casual'. 

Let's scroll after our Mongo stuff right here and let's create a section that I will comment `// SQL`. So, if you see any problems with SQL, you know that you need to go into this code here. 

And the export can stay after because we're going to export the new database that we'll create as well. So what we want to create first is a variable called sequelize and use a `new Sequelize()`, and that's why I did a capital S on this one, so we don't mix up the two. 

And we're going to create a new database, a new SQL database. And the next two values are basically the login and password `null, null,`, so this is not a course on SQL databases, so I'm not going to focus on any of that for now but if you want more information on it, take a course on Sequelize and SQLite and you'll get more details around that. 

And then what we're going to do is use the dialect of SQLite. So basically, we're mentioning which dialect we're using. And then where the storage is going to be, so where our database is going to be. The reason why we're using Sequelize and SQLite is because we're able to create a database or persistence inside of our project without having an external database that is huge  and without having to create a server like we've done for Mongo. 

So, this will create a file and this is where our persistence will be (pretty much like you do with Redis.) We will call this file `aliens.sqlite`. 

And once we start our server, you're going to see that file appear in our root directory here.

```jsx
// SQL 
const sequelize = new Sequelize('database', null, null, {
    dialect: 'sqlite',
    storage: './aliens.sqlite',
});
```



Okay, so now that we have created a new database, let's create our schema. 

So, we're going to create a new schema called Aliens and we're going to leverage the sequelize database that we just created and define it, so we're defining the aliens schema. 

```jsx
const Aliens = sequelize.define('aliens', {
    firstName: { type: Sequelize.STRING },
    lastName: { type: Sequelize.STRING },
    planet: { type: Sequelize.STRING },
});
```

Okay, so our schema is created. 

Now the next thing, we need to do is sync what we just created and we'll force it. So these are specific commands related to Sequelize, so it'll be forced to sync once we start the server. And then once you have been synced, we'll actually create the fake data. 

So, for this one (SQLite database), we'll simply create fake data that we'll be able to query with GraphQL. Let's go ahead and do that. And this is where our `casual` and `lodash` modules will become useful. 

So we're using underscore, so `lodash`, to basically create 10 times `casual` data that we'll name here. So, it will go through that command below 10 times. It will create in our database called Aliens 10 different people with a firstName and lastName and et cetera, et cetera. 

```jsx
Aliens.sync({ force: true }).then(() => {
    _.times(10, (i) => {
        Aliens.create({
            firstName: casual.first_name,
            lastName: casual.last_name,
            planet: casual.word,
        });
    });
});
```

And then finally, you are exporting Friends and Aliens. 

All right, so let me quickly recap what's happening here. So, we are creating a new database here. We're using the sqlite dialect and the storage is going to be in the main directory here. 

Then we are defining what the schema is going to look like, so we're going to have a firstName, lastName, planet, and these are all types of string. 

And then finally, we are going to force the creation of a new data whenever the server starts. So whenever we start the server, you're going to see 10 items being created on your console log. And they will be created with `casual` . There you go. 

@ `dbConnectors.js`

```jsx
import mongoose from 'mongoose';
import Sequelize from 'sequelize';
import _ from 'lodash';
import casual from 'casual';

// Mongo connection
mongoose.Promise = global.Promise;
mongoose.connect('mongodb://localhost/friends', {
    useMongoClient: true
});

const friendSchema = new mongoose.Schema({
    firstName: {
        type: String
    },
    lastName: {
        type: String
    },
    gender: {
        type: String
    },
    age: {
        type: Number
    },
    language: {
        type: String
    },
    email: {
        type: String
    },
    contacts: {
        type: Array
    }
});

const Friends = mongoose.model('friends', friendSchema);

// SQL 
const sequelize = new Sequelize('database', null, null, {
    dialect: 'sqlite',
    storage: './aliens.sqlite',
});

const Aliens = sequelize.define('aliens', {
    firstName: { type: Sequelize.STRING },
    lastName: { type: Sequelize.STRING },
    planet: { type: Sequelize.STRING },
});

Aliens.sync({ force: true }).then(() => {
    _.times(10, (i) => {
        Aliens.create({
            firstName: casual.first_name,
            lastName: casual.last_name,
            planet: casual.word,
        });
    });
});

export { Friends, Aliens };

```



And the last thing that we need to do is to create a type inside of our schema, so our GraphQL schema needs to have a type for alien. Otherwise, it's not going to accept anything inside of GraphQL when we query, and when we create the new items, so let's go ahead and create that as well. 

So, let's go below our type Friend, and create a type called Alien

@ `schema.js`

```jsx
    type Alien {
        id: ID
        firstName: String
        lastName: String
        planet: String
    }
```

Okay, so now we have a portion of our SQL database set up. We'll leave updating our resolvers as we go through GraphQL's query features, so let's move on. 



Test, if you run

```bash
yarn start
```

You will see the fake Alien data created in the terminal

```bash
sequelize deprecated String based operators are now deprecated. Please use Symbol based operators for better security, read more at http://docs.sequelizejs.com/manual/tutorial/querying.html#operators node_modules/sequelize/lib/sequelize.js:242:13
Running server on port localhost:8080/graphiql
Executing (default): DROP TABLE IF EXISTS `aliens`;
Executing (default): CREATE TABLE IF NOT EXISTS `aliens` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `firstName` VARCHAR(255), `lastName` VARCHAR(255), `planet` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL);
Executing (default): PRAGMA INDEX_LIST(`aliens`)
Executing (default): INSERT INTO `aliens` (`id`,`firstName`,`lastName`,`planet`,`createdAt`,`updatedAt`) VALUES (NULL,'Devyn','Hayes','pariatur','2018-02-28 00:23:10.027 +00:00','2018-02-28 00:23:10.027 +00:00');
Executing (default): INSERT INTO `aliens` (`id`,`firstName`,`lastName`,`planet`,`createdAt`,`updatedAt`) VALUES (NULL,'Sammie','Wolff','nostrum','2018-02-28 00:23:10.031 +00:00','2018-02-28 00:23:10.031 +00:00');
Executing (default): INSERT INTO `aliens` (`id`,`firstName`,`lastName`,`planet`,`createdAt`,`updatedAt`) VALUES (NULL,'Zita','Johns','eum','2018-02-28 00:23:10.032 +00:00','2018-02-28 00:23:10.032 +00:00');
Executing (default): INSERT INTO `aliens` (`id`,`firstName`,`lastName`,`planet`,`createdAt`,`updatedAt`) VALUES (NULL,'Alejandrin','Schmitt','a','2018-02-28 00:23:10.032 +00:00','2018-02-28 00:23:10.032 +00:00');
Executing (default): INSERT INTO `aliens` (`id`,`firstName`,`lastName`,`planet`,`createdAt`,`updatedAt`) VALUES (NULL,'Holly','Cremin','est','2018-02-28 00:23:10.032 +00:00','2018-02-28 00:23:10.032 +00:00');
Executing (default): INSERT INTO `aliens` (`id`,`firstName`,`lastName`,`planet`,`createdAt`,`updatedAt`) VALUES (NULL,'Skylar','Kshlerin','tempora','2018-02-28 00:23:10.032 +00:00','2018-02-28 00:23:10.032 +00:00');
Executing (default): INSERT INTO `aliens` (`id`,`firstName`,`lastName`,`planet`,`createdAt`,`updatedAt`) VALUES (NULL,'Marietta','Nader','inventore','2018-02-28 00:23:10.033 +00:00','2018-02-28 00:23:10.033 +00:00');
Executing (default): INSERT INTO `aliens` (`id`,`firstName`,`lastName`,`planet`,`createdAt`,`updatedAt`) VALUES (NULL,'Kevon','Langworth','nihil','2018-02-28 00:23:10.033 +00:00','2018-02-28 00:23:10.033 +00:00');
Executing (default): INSERT INTO `aliens` (`id`,`firstName`,`lastName`,`planet`,`createdAt`,`updatedAt`) VALUES (NULL,'Brook','Barton','quibusdam','2018-02-28 00:23:10.033 +00:00','2018-02-28 00:23:10.033 +00:00');
Executing (default): INSERT INTO `aliens` (`id`,`firstName`,`lastName`,`planet`,`createdAt`,`updatedAt`) VALUES (NULL,'Aubrey','Harvey','harum','2018-02-28 00:23:10.033 +00:00','2018-02-28 00:23:10.033 +00:00');
```















# 4. Mutations

## Add new items with mutations

What I want to do on this video is to add a tool that will allow you to cross check that there are new items in your Mongo database. 

First make sure that your Mongo database is actually on, 

```bash
yarn start
```

now look in the coonsole for GraphiQL webpage in the browser, so you should see these little lines here, so receive client connection accepted, things like that. So if this is not running make sure to run your Mongo database. 

Okay, so the tool that I want you to install is called **Robo 3T** and it's on [RoboMongo.org](RoboMongo.org) and it's a free tool that you can install on Mac, Windows, and Linux. 

So once you are on this website click on download Robo 3T and then click on download and just open that DMG file, you just simply drag and drop in the application and you have it completely installed. 

So the very first time you actually open Robo 3T, you need to click on create, and then you can call this connection anything you want and just accept all the defaults. 

So basically this is how you're going to connect to the local database, so if you had your Mongo database remotely on a domain then this is where you would enter the remote address and most likely there would be documentations, for example, if you're doing cloud Mongo database then you would have all the documentation to properly connect to it externally, but in this particular case we are using localhost one and the port is the same so all you have to do at this point is save it. 

The very first time that you are running your database you won't see friends because we haven't created the friends database with the new data.

So let's refresh our browser again (GraphiQL) and then let's use the last mutation that we created. 

So remember your previous video, we used this specific mutation here. So let's go ahead and use that. Again, you can always use the documentation explorer to help you when you're doing your queries and mutations. So in this case we can use create friend and create friend takes an input and that input is an object of friend input, like so. 

So it absolutely needs a first name, so if you don't enter a first name GraphiQL is going to give you an error. The id is created by the actual resolver, so we don't need to enter an ID, but we definitely need to enter a first name. 

Okay, so once you have your create friend object in there then you can ask the query to give you a few items in return once the new item has been created, so lets get ID, and first name, and the last name, and leave it at that, and let's create our new item. 

So, we got the confirmation here that we have created a new item, but we want to make sure that it is in the Mongo database. So this is where Robo 3T comes into play. So, let's go ahead and switch to Robo 3T, like so, and then just tap on friends which is the new database. 

So now you should see this database if you've done this command and you have a return ID plus first name and last name. You should be good to go and you should see friends now. If you don't, maybe because it hasn't been refreshed. 

You basically refresh like so, you right-click on the local database, refresh, and then you should see this. So click on friends, collections, and then you have a collection called friends and I have two items. So I created this item in the past, so this is why I see this, but this is the second item or the item that we just created. So if you see what you just created with the ID, the first name, last name, and so on, so forth, that means that everything is working nicely and you don't have to worry about any of the code that you've just written, it's working. 

Okay, so as you can see, it's fairly easy to add a mutation to our server, so let's continue working on our code. 



## Update items with mutations

In this scenario where you need to update items in the database with GraphQL, we also need to set up the proper mutation to do so. 

@ `schema.js`

And then, here, in the type Mutation, we need to create a new Mutation, and this one we'll call updateFriend. And the input is going to be exactly the same thing, so input FriendInput, and then, we return a Friend, as simple as that. 

```jsx
    type Mutation {
        createFriend(input: FriendInput): Friend
        updateFriend(input: FriendInput): Friend
    }
```



Now @ `resolvers.js` 

Just below the createFriend, we're going to create the resolver for Mongo to update a specific Friend. 

So, as you may have guessed, a specific Friend takes an input, like we've done for adding a new Friend, so we start with a root, and then we run a function. So, inside of that function, we are going to return, basically updating this Friend. So we'll use Promise because, when we are making the call to Mongo, we are not going to return a response until we get a response back from Mongo. So this is why we're using Promise. And we're using again resolve, and we're using object. And then, we're going to, basically, use the friends database, so we are using Friends. 

So, as you remember previously, we had imported Friends, which we've used to create a new Friend here. So we're going to use the Friends database to update.  

So the function that comes with mongoose to update a specific item is called `findOneAndUpdate`. And it's a function, which takes a few parameters, so we need an id. So we need to identify the id that we're actually changing, and then we're going to pass the input as the things that we need to change inside of particular id. 

So this particular function, `new: true`, means that if we don't have an item in the database that matches to that, then create a new one, and then we'll use error and friend as the parameter so we can do something with the Promise, so like we've done in the past, and this is basically going to be exactly what we've done here. 

So, `if (err) reject(err) else resolve(friend)`. So, it's not going to be the newFriend but the friend. 

```jsx
        updateFriend: (root, { input }) => {
            return new Promise(( resolve, object) => {
                Friends.findOneAndUpdate({ _id: input.id }, input, { new: true}, (err, friend) => {
                    if (err) reject(err)
                    else resolve(friend)
                })
            })
        }
```



So, we have our resolver that will speak to Mongo, update the particular item in our Mongo database and then resolve inside of our GraphQL. 

So, let's go ahead and save that

@ `resolvers.js`

```jsx
import mongoose from 'mongoose';
import { Friends } from './dbConnectors';

// resolver map
export const resolvers = {
    Query: {
        getFriend: ({ id }) => {
            return new Friend(id, friendDatabase[id]);
        },
    },
    Mutation: {
        createFriend: (root, { input }) => {
            const newFriend = new Friends({
                firstName: input.firstName,
                lastName: input.lastName,
                gender: input.gender,
                age: input.age,
                language: input.language,
                email: input.email,
                contacts: input.contacts
            });

            newFriend.id = newFriend._id;

            return new Promise((resolve, object) => {
                newFriend.save((err) => {
                    if (err) reject(err)
                    else resolve(newFriend)
                })
            }) 
        },
        updateFriend: (root, { input }) => {
            return new Promise(( resolve, object) => {
                Friends.findOneAndUpdate({ _id: input.id }, input, { new: true}, (err, friend) => {
                    if (err) reject(err)
                    else resolve(friend)
                })
            })
        }
    },
};

```





Let's open up our server, so let's go to View, Integrated Terminal. There's no errors here, we're good to go, and let's go to our browser and refresh our browser as well. 

Now, if we take a look at the mutations in our documentation, we should have now update Friend. 

So, let's go ahead and go to Robo 3T so we get at least an id of a friend that we want to change. 

So let's get this guy here. Okay, so we'll update this guy here. (So, a little tip for Robo 3T. If you want to copy things in this view, you can't. If you want to copy things, you need to change the view. So, the view I usually go to to copy and paste stuff is the last one here, so the document mode,) and then, what I'm going to do is scroll and then just copy this particular id here, like so, and then change my mutation entirely. 

Mutation, updateFriend, then this function takes an input, and my input is the id that I want to change is this one. And what I want to change on this guy, so let's take a look, what do we have for a name?

 We have Tracey, let's change it to Manny. So firstName Manny, and then age 34. That's not my real age, but I'm just saying that for fun, and then again, let's return something out of that. So let's return the first name, the age, and so. So, let's go ahead and run it. We run it, firstName has been updated, the age has been updated, but we got that response on GraphQL. 

Let's check that for sure on Robo 3T. So let's go back here. So, Robo 3T doesn't automatically update the values here, so you need to refresh yourself. So again, right-click on Local, Refresh, click on friends, click on Collections, click on friends again, and then it's the second one here, and you can see that the firstName has been changed to Manny and the age to 34. So there you have it. Now you'll be able to update any items with GraphQL. 



To Update

```javascript
mutation {
  updateFriend(input: {
    id: "5a95e09d19c5b032d63d919e",
    firstName: "Francine"
  }) {
    id
    firstName
  }
}
```



Returns

```javascript
{
  "data": {
    "updateFriend": {
      "id": "5a95e09d19c5b032d63d919e",
      "firstName": "Francine"
    }
  }
}
```



















## Delete items with mutations

The final mutation we need for our GraphQL severs is to be able to delete data. So let's add this mutation. 

So, again, like we've done in the past, we need to first add the mutation in our type mutations, so let's go ahead and add a new one, and we'll call deleteFriend, and we'll take an ID, and it needs absolutely an ID, so that's why I've put the exclamation point here. 

And then we'll return a string this time, because once we delete a friend, well, it's no longer a part of the database so we shouldn't be returning the friend itself, because it's no longer there, so if we did that, it would give you a null answer. So let's return a message instead, that yes, something has been deleted in our database. So, once we're done with that, save

@ `schema.js`

```jsx
    type Mutation {
        createFriend(input: FriendInput): Friend
        updateFriend(input: FriendInput): Friend
        deleteFriend(id: ID!): String
    }
```





Then @ `resolvers.js`. 

We'll create a brand new function, just below the updateFriend. 





So, on line 39, get a comma in there, and then return, and then deleteFriend, which, again, takes root, and the input this time is the ID. And this time, we'll return, again, a promise, 'cause we are calling onto a different server, so we want to make sure that before we actually resolve anything inside of our own GraphQL server, we get a response back from Mongo. So, we'll use resolve and object, like before, and if you want to copy and paste this particular area to save some time, most of it will be very similar. And then, inside here, we're using friends, and then using a simple function called, well, guess what, remove. And this function will take the ID that we need, so _id, because Mongo works with underscore, and we'll pass the ID that is in our input here. So, we'll pass in this particular argument here, in here, to select which one we need to remove. And then we'll do the err, and we don't even need the friend, so we could remove that particular line here. And then, do the function, and if err, reject err, else, and this is where it's different from resolving something, because we're not resolving friend, we are going to resolve a particular message. Successfully deleted friend, like so. And let's make sure we type that properly. And that's probably our delete function.

```jsx
        deleteFriend: (root, { id }) => {
            return new Promise((resolve, object) => {
                Friends.remove({ _id: id}, (err) => {
                    if (err) reject(err)
                    else resolve('Successfully deleted friend')
                })
            })
        }
```





 There's nothing more that we need, so save that, 

@ `resolvers.js`

```jsx
import mongoose from 'mongoose';
import { Friends } from './dbConnectors';

// resolver map
export const resolvers = {
    Query: {
        getFriend: ({ id }) => {
            return new Friend(id, friendDatabase[id]);
        },
    },
    Mutation: {
        createFriend: (root, { input }) => {
            const newFriend = new Friends({
                firstName: input.firstName,
                lastName: input.lastName,
                gender: input.gender,
                age: input.age,
                language: input.language,
                email: input.email,
                contacts: input.contacts
            });

            newFriend.id = newFriend._id;

            return new Promise((resolve, object) => {
                newFriend.save((err) => {
                    if (err) reject(err)
                    else resolve(newFriend)
                })
            }) 
        },
        updateFriend: (root, { input }) => {
            return new Promise(( resolve, object) => {
                Friends.findOneAndUpdate({ _id: input.id }, input, { new: true}, (err, friend) => {
                    if (err) reject(err)
                    else resolve(friend)
                })
            })
        },
        deleteFriend: (root, { id }) => {
            return new Promise((resolve, object) => {
                Friends.remove({ _id: id}, (err) => {
                    if (err) reject(err)
                    else resolve('Successfully deleted friend')
                })
            })
        }
    },
};

```

and then go inside of GraphQL, and let's go ahead and grab someone we can delete. 

So, inside of your database here, refresh, click on friends, click on collections, then click on friends again, and then let's select this guy here. So, again, like I said in the past, the way to copy and paste inside of Robo T is by going into the **document view**, so click here, and let's go ahead and select this specific ID. 

And then let's go in GraphiQL and let's go ahead and make sure that we refresh the server. So now that we have the specific mutation that we just created, so click on mutation to make sure that deleteFriend is there, so it is. 

So let's go ahead and type out this mutation. So, create an object and deleteFriend, deleteFriend takes an ID to delete, and then let's insert the ID that we just copied, and that's all you need. So, once you run this particular command, successfully deleted friend. 

So, if we didn't answer a string or a message in here, we would get a null as a result if we wanted to return a friend, because that friend does not exist anymore in the Mongo database. 

So let's check that for sure. So, let's go in Robo T, and close that out, because right now, it hasn't been updated, so let's refresh that again. Click on friends, collections, friends, and boom, it's no longer there. So, now that we have the ability to add, update, and delete items into our database, let's move on to more advanced type of queries. 



To delete

```javascript
mutation {
  deleteFriend (id: "5a95d44ec00d3b2c540caadc")
}
```

Returns

```javascript
{
  "data": {
    "deleteFriend": "Successfully deleted friend"
  }
}
```























# 5. Queries in Depth

## Simple query with persistence

Now that we have some data to play with, it's time to explore the many options available with queries and start with a simple one leveraging the SQL database we created. 

@ `schema.js` 

I want you to add one more query called getAliens, and what we'll return is an array of Alien, and by now we should have Alien also defined, so the type Alien is here, so we're good to go there. 

```jsx
    type Query {
        getFriend(id: ID): Friend
        getAliens: [Alien]
    }
```

Whenever you have any type or Queries or Mutations that are actually returning something, you need to make sure that you have that type defined somewhere in your schema. 

For example, we have the type Alien defined here, we have the type Friend defined here. 

When we are doing an input, we are leveraging here the ContactInput, so this needs to be defined in the input here, and so on, so forth. This is very important and you will get error messages if you don't have that. 

Let's make sure we Save. 

Then @ `resolvers.js`

We need to create a brand new resolver to get our aliens from the SQL database. Let's go ahead and do that. Right below the getFriend, just hit Return on line nine, and then just create a new one called getAliens and then this will be a function that will return from the database Aliens, so we're leveraging the database Aliens, so guess what, if we are using Aliens here, we need to import it. Let's import Aliens, now we have access to it, and then findAll, which is a function to find all the friends related to this particular database, like so. Save that. 

```jsx
import mongoose from 'mongoose';
import { Friends, Aliens } from './dbConnectors';

// resolver map
export const resolvers = {
    Query: {
        getFriend: ({ id }) => {
            return new Friend(id, friendDatabase[id]);
        },
        getAliens: () => {
            return Aliens.findAll();
        }
    },
    
    ...
```



OK, so now we can go ahead and test this, so let's go into our GraphQL server, and let's make sure we also refresh it, so let's go GraphQL, like so, and we should see the query appear in here, so getAliens is there, so let's remove that. Let's first do the query, so let's do a query and then getAliens, like so, and Aliens doesn't require anything. But let's use Prettify. I want to show you a little shortcut, so you could have done it this way, so let's remove that, and we could have done it simply by doing getAliens, like so. If you don't want to write queries or mutations every single time, you can do a shorter way like so. Let's run it, and then we have all the aliens that sits in our database. 

The reason why we only get the ids is because we didn't enter anything. When we don't enter anything, it assumes that you at least want the ids. 

Let's add more stuff to it. Let's add the firstName, lastName, and then the planet, and then rerun that query again, and then we'll get all these results. 

If you didn't realize it yet, we're actually getting data from our SQL database now, we're not getting data from Mongo. If we go back to our server here, and open up our server by going to Integrated Terminal, we basically got the data that was created when the server was first created here. 

Again, whenever we rerun our server, this force, the sync that we've done in our code actually reintroduces new data in that particular server. It's persistence but we're still forcing the data to be renewed every single time our server is started. OK, so that's from a SQL perspective. Now that we've got a simple query, which returns the list of aliens we created into our SQL database, let's move on.



Get all the Aliens from SQLite DB

```javascript
query {
  getAliens {
    id
    firstName
    lastName
    planet
  }
}
```

Returns

```javascript
{
  "data": {
    "getAliens": [
      {
        "id": "1",
        "firstName": "Berniece",
        "lastName": "Denesik",
        "planet": "nemo"
      },
      {
        "id": "2",
        "firstName": "Elizabeth",
        "lastName": "Hermiston",
        "planet": "quia"
      },
      {
        "id": "3",
        "firstName": "Waylon",
        "lastName": "Corwin",
        "planet": "voluptatibus"
      },
      {
        "id": "4",
        "firstName": "Yvette",
        "lastName": "Bergnaum",
        "planet": "velit"
      },
        ...
        
```























## Querying with arguments

Before we start this video you need to add a new item with a mutation. Just like we did in a previous video. As I mentioned previously I had one for testing. So you'll want to add that before moving on with this video. 

Doing a query with an argument is as easy as passing input into a mutation like we've done in our code thus far. 

Let me demonstrate. 

@ `schema.js` 

So we'll change `getFriend(id: ID): Friend` to getOneFriend and we'll pass an id and we absolutely need an id so we need an exclamation point here. And then we'll return a friend. And let's make sure it's a capital F like so. 

So we've done a few of these querieswith arguments. If you take a look at all the mutations that we've done with arguments it's pretty much the same thing. We're passing an id here and we'll return a single Friend so let's save that 

```jsx
    type Query {
        getOneFriend(id: ID!): Friend
        getAliens: [Alien]
    }
```

and all we need to do at this point is change our resolver. 

@ `resolvers.js`

So right now we have getFriend 

```jsx
        getFriend: ({ id }) => {
            return new Friend(id, friendDatabase[id]);
        },
```



so let's completely remove that and change it to getOneFriend like so and as you saw in the past for this one we'll need root and we're passing an id and then we'll take that id and do something with it. And let's do a comma right away so we don't get that error. And then we'll return from our Mongo database so again like we've done in the past for creating new items we need to use a promise because we're calling into a second server so we need to have a response before we can actually resolve it. So let's go ahead and do that. Promise and we'll pass resolve and an object and again it's going to be a function and then what we'll do is use the Friends database. So we need find by id so basically right now in the database we are using an id to find by id. As simple as that. So we're passing inside of that function the id that we got in here and then we'll do the usual error and returning a friend like so. And everything else you can guess that it's going to be pretty much the same as what we've done below here. So you can literally copy and paste this line here. So on line 42. You can copy this guy here. So those two lines. And paste them here. So if there's an error, then reject the error. Else resolve the friend that we are recalling into the database. So semicolon here and we're good to go. Let's put another one there. Save all this.

```jsx
        getOneFriend: (root, { id }) => {
            return new Promise((resolve, object) => {
                Friends.findById(id, (err, friend) => {
                    if (err) reject(err)
                    else resolve(friend)
                });
            });
        },
```



 Let's make sure our server's running properly. So click on view, integrate a terminal. Server's running fine and actually has created new items in our sql database So when you see this it means that it's working. It usually restarts on its own around here and then does all this. Don't worry about the crash. That was when we were still working on our code when saved the schema. So we're good to go and let's go into graph ql. Let's refresh graph ql to make sure that we got the latest and the greatest. Check our queries, getOneFriend. Okay, we're good to go. So let's get an ID from roboT. Let's also refresh roboT. Click on friends, collections, friends again. And we only have one so we'll use that one to get the data so let's go ahead and click on docmen view. So we can grab the ID, copy and then go and grab ql and let's use a shorter way so getOneFriend which takes an id. Insert the id like so and then what data do we want from this guy. So we want the first name or the last name. Do we have a gender? I'm not so sure, but we'll get null if there's no gender. And let's run the query and there was a gender so we're good to go and we got the first name, last name based off this id. Okay, so we queried and single user with an argument and got the results.



Query with an argument

```javascript
query {
  getOneFriend(id: "5a95e09d19c5b032d63d919e"){
    firstName
    lastName
    gender
    language
    contacts {
      firstName
      lastName
    }
  }
}
```

Returns

```javascript
{
  "data": {
    "getOneFriend": {
      "firstName": "Francine",
      "lastName": "Schmoozer",
      "gender": "FEMALE",
      "language": "German",
      "contacts": [
        {
          "firstName": "Hank",
          "lastName": "Googler"
        },
        {
          "firstName": "Lizzie",
          "lastName": "Scher"
        }
      ]
    }
  }
}
```

















## Querying with aliases

Aliases is a feature that comes right out of the box with GraphQL, and doesn't require any coding. It is basically a way do multiple queries, and name them with anything you want to properly label them. 

Let me demonstrate, so right now we only have one item in our database. If we take a look at the database on Robo T, so we refresh, and go to our friends, we only have one item. 

So, we won't be able to do aliases if we don't have more than one item, so let's go ahead and add a few. 

Let's use history for that. Let's go to mutation, create friend, and let's recreate this guy here. So that's cool, we already have something we can recreate, and let's add a third one. Let's add \"Stephanie Smoochyish,\" and she's a female, and she's 32, and she speaks English. Alright, so let's create this one, and we've got three items in our database. 

Let's make sure by going to Robo T, and we've got our three items here, perfect. Let's go in document mode because we'll need to copy and paste at least the IDs. Let's go and copy the first one, so this one is the one with Emmanuel, and let's create aliases. 

So, the way it works with aliases, it basically works the same way as we've done before with queries the only difference is that instead of running just one, you can run multiple and label them. So, let's go ahead and do one. We'll label the first one, \"one,\" just for fun, and then do a colon, and then do your query, so, get one friend with the ID like so, and this is the ID, and then you do as usual so, I want to get the first name and then the last name, and then what you can do is run a second query. Let's call this one \"second,\" and you can call it anything you want. It doesn't matter, and then get one friend with a second ID. So, let's go and grab a second one. Let's grab the last one, like so. Copy, colon again, and then paste, and then ask for different things in that one. So, we could ask for last name, gender, and then age for that second query. You can even call this one, second with age, be more specific. So you can be contextual in the name of your labels, and that's what an aliases is, and then run your queries. So, run it, and then in your results you get, well, for the first one you get first name, last name, and then on the second one with age, you get the last name, gender, and age. So, this is how easy it is to do aliases, and using aliases could be useful when the front end is calling the back end for specific users and could construct a query with a name or ID of the user to get the result with the proper label. I'm sure you can find a specific use for this feature as you explore using GraphGL with your own projects So, let's move on. "



Name each query with an alias

```javascript
query {
  friendWithData: getOneFriend(id: "5a95e09d19c5b032d63d919e"){
    firstName
    lastName
    gender
    language
    contacts {
      firstName
      lastName
    }
  }
  simpleFriend: getOneFriend(id: "5a95e09d19c5b032d63d919e"){
    firstName
    gender
  }
}
```



Get exactly the data you want in one query

```javascript
{
  "data": {
    "friendWithData": {
      "firstName": "Francine",
      "lastName": "Schmoozer",
      "gender": "FEMALE",
      "language": "German",
      "contacts": [
        {
          "firstName": "Hank",
          "lastName": "Googler"
        },
        {
          "firstName": "Lizzie",
          "lastName": "Scher"
        }
      ]
    },
    "simpleFriend": {
      "firstName": "Francine",
      "gender": "FEMALE"
    }
  }
}
```













## Querying with fragments

Like Aliases, fragments are a neat feature that comes built in with GraphQL and is very useful when we start requesting the same data across several items. Let me demonstrate. So in this case we actually ask for different data for the two requests here. So, what we'll do is change those two and then use a fragment to ask for the same data but not have to re-type the same thing across. So, let's say for example, we had first name, last name, here as well. And then we'd have like 20 other queries in the same request. Then that would become very repetitive. And that's what we want to avoid with a fragment. So what we do is basically do a second line below and call this one fragment. And we call, so for example, we call this one friend fragment on friend. And this is how we type a fragment. And then what we do is specify what we want to return on this fragment. So, first name, last name. And then what we have to do is change on each of our queries with three dots and then say friend fragment and then do the same on the second line. So copy and paste it here. So basically what we'll do is do those two queries like we've done before and leverage your fragment to tell it exactly what we want to return on those two queries. And this is what a fragment is, is to avoid repetitive typing in your queries. So if we run this, like so, now we get the first name, last name, for both queries. And we've done this through a fragment. So you can see how we could use this for multiple queries. So let's say, for example, we had multiple queries with the same type of query and basically asking for the same data here, then we would get all these different queries return first name and last name. And you could do this for all types of items that you want to return on your queries. And if there's something or someone that doesn't have a specific item in their queries, it will return null. So, for example, email, I don't think any of them has an email. Or just the one. And then the second one will return null and this is perfectly okay. So as you can see, and very much like Aliases, the use-case for this is similar and could be used for getting multiple items and typing a lot less in your queries.

Query with fragment

```javascript
query {
  friendWithData: getOneFriend(id: "5a95e09d19c5b032d63d919e"){
    ...friendFragment
  }
  simpleFriend: getOneFriend(id: "5a95fcaa4f3c923bd73d0007"){
    ...friendFragment
  }
}

fragment friendFragment on Friend {
    firstName
    lastName
    gender
    language
    contacts {
      firstName
      lastName
    }
}
```

Returns

```javascript
{
  "data": {
    "friendWithData": {
      "firstName": "Francine",
      "lastName": "Schmoozer",
      "gender": "FEMALE",
      "language": "German",
      "contacts": [
        {
          "firstName": "Hank",
          "lastName": "Googler"
        },
        {
          "firstName": "Lizzie",
          "lastName": "Scher"
        }
      ]
    },
    "simpleFriend": {
      "firstName": "Spanky",
      "lastName": "Smythe",
      "gender": "MALE",
      "language": "English",
      "contacts": [
        {
          "firstName": "Chuck",
          "lastName": "Gerber"
        },
        {
          "firstName": "Albert",
          "lastName": "Schmucker"
        }
      ]
    }
  }
}
```









# Conclusion

## Next steps
